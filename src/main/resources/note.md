
#### 你所知道的查找算法
1. 遍历
    * 时间复杂度
        1. 遍历从1开始遍历到100 for循环解决 O(n)
    
2. 哈希(最高效)
    * hash冲突
    * HashMap （链表+红黑树: 处理Hash冲突）
        
3. 二叉搜索树（二叉排序树，二叉查找树）
    * 时间复杂度（就是树的深度） 2^x=n(树的高度) => x=log2^n => logn
    * 特点
        1. 如果它的左子树不为空，则左子树上结点的值都小于根结点。
        2. 如果它的右子树不为空，则右子树上结点的值都大于根结点
        3. 子树同样要遵循以上两点
    * 为什么又叫做二叉排序树？二叉树的遍历方式：前 中 后 层次（mysql）
    只要一棵树是二叉搜索树，那么它的中序遍历一定是有序的，左跟(输出)右 -- 堆排序，归并排序，大项堆，小项堆
    左跟(输出)右 -> 即左跟节点，一次取右子树
 
4. 红黑树（特殊的二叉搜索树）: 高效的查找算法数据结构
    * 链表 -> 二叉树 -> 二叉查找树 -> 特殊的二叉查找树(自平衡的二叉查找树)
    * 为了解决分叉搜索树中左右子树只存在一边的搜索情况
    ![redTree](/images/红黑树.png)
    
    * 性质：  
    1. 每个结点不是红色就是黑色
    2. 不可能有连在一起的红色结点
    3. 根结点都是黑色 root根结点（入度为0的结点）
    4. 每个红色结点的子结点都是黑色，叶子结点都是黑色：出度为0 满足了性质就可以近似的平衡了。不一定要红黑。
    
    * 为了满足红黑树的性质，因此出现了旋转
    1. 改变颜色：红变黑，黑变红
    2. 左旋：针对于点旋，但是点上面的子树也要跟着转。（逆时针）
    3. 右旋：
    
    * 旋转和颜色变换规则: 所有插入的点默认为红色.
    1. 变颜色的情况：当前结点的父亲是红色，且它的祖父结点的另一个子结点也是红色（叔结点）。
        (1) 把父结点设为黑色
        (2) 把叔结点也设为黑色
        (3) 把祖父也就是父结点的父结点(爷爷结点)设为红色
        (4) 把指针定义到父结点设为当前要操作的（爷爷）分析点变换规则。
    2. 左旋：当前父亲结点是红色，叔叔结点是黑色的时候，且当前的结点是右子树。左旋以父结点作为左旋。
    3. 右旋：当前父结点是红色，叔叔结点是黑色的时候，且当前的结点是左子树。右旋。
        (1) 把父结点设为黑色
        (2) 把爷爷结点设为红色
        (3) 以爷爷旋转
    
5. B+树
    
6. B-Tree 

7. 平衡树（AVL树 -- 追求极致的平衡，理想状态 折中）

8. 二分
    * 条件  
        必须是有序的
    * 典型实例 (转换为数据结构表现为二叉搜索树)
        1. 给定一个0～100的数字，让你猜，每次根据你猜的数字告诉你是大了还是小了. 假如给定56
            1. 第一次猜(0+100)/2 = 50
            2. 第二次猜(50+100)/2 = 75
    * 时间复杂度
        1. 2^x=n(树的高度) => x=log2^n => logn
      
9. 索引
    
10. 插值
11. bfs&dfs（广度优先搜索&深度优先搜索）
    图论里的遍历

    
