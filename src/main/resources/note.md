
#### 你所知道的查找算法
1. 遍历
    * 时间复杂度
        1. 遍历从1开始遍历到100 for循环解决 O(n)
    
2. 哈希(最高效)
    * hash冲突
    * HashMap （链表+红黑树: 处理Hash冲突）
    
3. B+树
    
4. 二叉搜索树（二叉排序树，二叉查找树）
    * 时间复杂度（就是树的深度） 2^x=n(树的高度) => x=log2^n => logn
    * 特点
        1. 如果它的左子树不为空，则左子树上结点的值都小于根结点。
        2. 如果它的右子树不为空，则右子树上结点的值都大于根结点
        3. 子树同样要遵循以上两点
    * 为什么又叫做二叉排序树？二叉树的遍历方式：前 中 后 层次（mysql）
    只要一棵树是二叉搜索树，那么它的中序遍历一定是有序的，左跟(输出)右 -- 堆排序，归并排序，大项堆，小项堆
    左跟(输出)右 -> 即左跟节点，一次取右子树
 
5. 红黑树（特殊工的二叉搜索树）: 高效的查找算法数据结构
    * 链表 -> 二叉树 -> 二叉查找树 -> 特殊的二叉查找树(自平衡的二叉查找树)
    * 为了解决分叉搜索树中左右子树只存在一边的搜索情况
    ![redTree](/images/红黑树.png)
    
    


6. 平衡树（AVL树 -- 追求极致的平衡，理想状态 折中）

7. 二分
    * 条件  
        必须是有序的
    * 典型实例 (转换为数据结构表现为二叉搜索树)
        1. 给定一个0～100的数字，让你猜，每次根据你猜的数字告诉你是大了还是小了. 假如给定56
            1. 第一次猜(0+100)/2 = 50
            2. 第二次猜(50+100)/2 = 75
    * 时间复杂度
        1. 2^x=n(树的高度) => x=log2^n => logn

        
8. B-Tree 
9. 索引
    
10. 插值
11. bfs&dfs（广度优先搜索&深度优先搜索）
    图论里的遍历

    
